package gains

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

// SchemaFor generates a JSON schema from a struct type T.
// The schema is generated by inspecting struct field tags.
//
// Supported tags:
//   - json:"name"      - Property name (required for inclusion)
//   - desc:"text"      - Description
//   - required:"true"  - Mark as required
//   - enum:"a,b,c"     - Enum values (comma-separated)
//   - min:"0"          - Minimum value (numbers)
//   - max:"100"        - Maximum value (numbers)
//   - minLength:"1"    - Minimum string length
//   - maxLength:"100"  - Maximum string length
//   - pattern:"regex"  - String pattern
//   - default:"value"  - Default value
//   - minItems:"1"     - Minimum array items
//   - maxItems:"10"    - Maximum array items
//
// Example:
//
//	type Args struct {
//	    Query  string `json:"query" desc:"Search query" required:"true"`
//	    Limit  int    `json:"limit" desc:"Max results" min:"1" max:"100"`
//	}
//
//	schema := gains.MustSchemaFor[Args]()
func SchemaFor[T any]() (json.RawMessage, error) {
	var zero T
	t := reflect.TypeOf(zero)

	// Handle pointer types
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	if t.Kind() != reflect.Struct {
		return nil, fmt.Errorf("SchemaFor: type %T is not a struct", zero)
	}

	schema := buildObjectSchema(t)
	return json.Marshal(schema)
}

// MustSchemaFor is like SchemaFor but panics on error.
func MustSchemaFor[T any]() json.RawMessage {
	schema, err := SchemaFor[T]()
	if err != nil {
		panic(err)
	}
	return schema
}

// schemaMap represents a JSON schema as a map for easy construction.
type schemaMap map[string]any

// buildObjectSchema creates a JSON schema for a struct type.
func buildObjectSchema(t reflect.Type) schemaMap {
	properties := make(map[string]schemaMap)
	var required []string

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Get JSON name
		jsonTag := field.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		// Parse json tag (handle ",omitempty" etc.)
		name := strings.Split(jsonTag, ",")[0]
		if name == "" {
			continue
		}

		// Build field schema
		fieldSchema := buildFieldSchema(field)
		properties[name] = fieldSchema

		// Check if required
		if field.Tag.Get("required") == "true" {
			required = append(required, name)
		}
	}

	schema := schemaMap{
		"type":       "object",
		"properties": properties,
	}

	if len(required) > 0 {
		schema["required"] = required
	}

	return schema
}

// buildFieldSchema creates a JSON schema for a struct field.
func buildFieldSchema(field reflect.StructField) schemaMap {
	schema := schemaMap{}

	// Add description if present
	if desc := field.Tag.Get("desc"); desc != "" {
		schema["description"] = desc
	}

	// Determine type and add type-specific properties
	fieldType := field.Type

	// Handle pointer types (makes field optional)
	if fieldType.Kind() == reflect.Ptr {
		fieldType = fieldType.Elem()
	}

	switch fieldType.Kind() {
	case reflect.String:
		schema["type"] = "string"
		addStringConstraints(schema, field.Tag)

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		schema["type"] = "integer"
		addNumericConstraints(schema, field.Tag)

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		schema["type"] = "integer"
		schema["minimum"] = 0
		addNumericConstraints(schema, field.Tag)

	case reflect.Float32, reflect.Float64:
		schema["type"] = "number"
		addNumericConstraints(schema, field.Tag)

	case reflect.Bool:
		schema["type"] = "boolean"

	case reflect.Slice, reflect.Array:
		schema["type"] = "array"
		itemSchema := buildTypeSchema(fieldType.Elem())
		schema["items"] = itemSchema
		addArrayConstraints(schema, field.Tag)

	case reflect.Map:
		if fieldType.Key().Kind() == reflect.String {
			schema["type"] = "object"
			valueSchema := buildTypeSchema(fieldType.Elem())
			schema["additionalProperties"] = valueSchema
		} else {
			schema["type"] = "object"
		}

	case reflect.Struct:
		// Nested struct
		nested := buildObjectSchema(fieldType)
		for k, v := range nested {
			schema[k] = v
		}

	default:
		schema["type"] = "string" // Fallback
	}

	// Add default value if present
	if def := field.Tag.Get("default"); def != "" {
		schema["default"] = parseDefaultValue(def, fieldType.Kind())
	}

	return schema
}

// buildTypeSchema creates a JSON schema for a Go type (used for array items, map values).
func buildTypeSchema(t reflect.Type) schemaMap {
	// Handle pointer types
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	switch t.Kind() {
	case reflect.String:
		return schemaMap{"type": "string"}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return schemaMap{"type": "integer"}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return schemaMap{"type": "integer", "minimum": 0}
	case reflect.Float32, reflect.Float64:
		return schemaMap{"type": "number"}
	case reflect.Bool:
		return schemaMap{"type": "boolean"}
	case reflect.Slice, reflect.Array:
		return schemaMap{
			"type":  "array",
			"items": buildTypeSchema(t.Elem()),
		}
	case reflect.Map:
		if t.Key().Kind() == reflect.String {
			return schemaMap{
				"type":                 "object",
				"additionalProperties": buildTypeSchema(t.Elem()),
			}
		}
		return schemaMap{"type": "object"}
	case reflect.Struct:
		return buildObjectSchema(t)
	default:
		return schemaMap{"type": "string"}
	}
}

// addStringConstraints adds string-specific constraints from tags.
func addStringConstraints(schema schemaMap, tag reflect.StructTag) {
	if enum := tag.Get("enum"); enum != "" {
		schema["enum"] = strings.Split(enum, ",")
	}
	if minLen := tag.Get("minLength"); minLen != "" {
		if v, err := strconv.Atoi(minLen); err == nil {
			schema["minLength"] = v
		}
	}
	if maxLen := tag.Get("maxLength"); maxLen != "" {
		if v, err := strconv.Atoi(maxLen); err == nil {
			schema["maxLength"] = v
		}
	}
	if pattern := tag.Get("pattern"); pattern != "" {
		schema["pattern"] = pattern
	}
}

// addNumericConstraints adds numeric constraints from tags.
func addNumericConstraints(schema schemaMap, tag reflect.StructTag) {
	if enum := tag.Get("enum"); enum != "" {
		parts := strings.Split(enum, ",")
		var values []any
		for _, p := range parts {
			if v, err := strconv.ParseFloat(strings.TrimSpace(p), 64); err == nil {
				values = append(values, v)
			}
		}
		if len(values) > 0 {
			schema["enum"] = values
		}
	}
	if min := tag.Get("min"); min != "" {
		if v, err := strconv.ParseFloat(min, 64); err == nil {
			schema["minimum"] = v
		}
	}
	if max := tag.Get("max"); max != "" {
		if v, err := strconv.ParseFloat(max, 64); err == nil {
			schema["maximum"] = v
		}
	}
}

// addArrayConstraints adds array-specific constraints from tags.
func addArrayConstraints(schema schemaMap, tag reflect.StructTag) {
	if minItems := tag.Get("minItems"); minItems != "" {
		if v, err := strconv.Atoi(minItems); err == nil {
			schema["minItems"] = v
		}
	}
	if maxItems := tag.Get("maxItems"); maxItems != "" {
		if v, err := strconv.Atoi(maxItems); err == nil {
			schema["maxItems"] = v
		}
	}
}

// parseDefaultValue parses a default value string into the appropriate type.
func parseDefaultValue(value string, kind reflect.Kind) any {
	switch kind {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if v, err := strconv.ParseInt(value, 10, 64); err == nil {
			return v
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		if v, err := strconv.ParseUint(value, 10, 64); err == nil {
			return v
		}
	case reflect.Float32, reflect.Float64:
		if v, err := strconv.ParseFloat(value, 64); err == nil {
			return v
		}
	case reflect.Bool:
		if v, err := strconv.ParseBool(value); err == nil {
			return v
		}
	}
	return value // Return as string for string types or unparseable values
}
