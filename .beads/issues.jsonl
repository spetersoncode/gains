{"id":"gains-2pb","title":"Add RunAgentInput type and Prepare helper to agui package","description":"## Summary\nMove the `RunAgentInput` struct from `cmd/aguiserver/handler.go` to the `agui` package. This type represents the AG-UI protocol's request schema and is transport-agnostic - every AG-UI server implementation needs this regardless of HTTP framework.\n\n## Current State\nThe type is defined in `cmd/aguiserver/handler.go:18-28`:\n```go\ntype RunAgentInput struct {\n    ThreadID       string                `json:\"thread_id\"`\n    RunID          string                `json:\"run_id\"`\n    Messages       []aguievents.Message  `json:\"messages\"`\n    Tools          []any                 `json:\"tools,omitempty\"`\n    Context        []any                 `json:\"context,omitempty\"`\n    State          any                   `json:\"state,omitempty\"`\n    ForwardedProps any                   `json:\"forwarded_props,omitempty\"`\n}\n```\n\nThe handler then has scattered logic to validate and convert this input (lines 67-100).\n\n## Proposed API\nAdd to `agui/input.go`:\n\n```go\n// RunAgentInput represents the AG-UI protocol request for running an agent.\n// This mirrors the AG-UI protocol specification.\ntype RunAgentInput struct {\n    ThreadID       string           `json:\"thread_id\"`\n    RunID          string           `json:\"run_id\"`\n    Messages       []events.Message `json:\"messages\"`\n    Tools          []any            `json:\"tools,omitempty\"`\n    Context        []any            `json:\"context,omitempty\"`\n    State          any              `json:\"state,omitempty\"`\n    ForwardedProps any              `json:\"forwarded_props,omitempty\"`\n}\n\n// PreparedInput contains validated and converted input ready for agent execution.\ntype PreparedInput struct {\n    ThreadID  string\n    RunID     string\n    Messages  []gains.Message\n    Tools     []Tool           // Parsed frontend tools\n    ToolNames []string         // Tool names for cleanup tracking\n}\n\n// Prepare validates the input and converts it to gains types.\n// Returns an error if Messages is empty or tool parsing fails.\nfunc (r *RunAgentInput) Prepare() (*PreparedInput, error)\n```\n\n## Benefits\n1. Documents the protocol schema in the library where it belongs\n2. Consolidates validation and conversion logic in one place\n3. Makes server implementations cleaner - they focus on HTTP concerns only\n4. Enables consistent behavior across different server implementations\n5. Users don't need to re-implement the same parsing/validation\n\n## Implementation Notes\n- Move type definition to `agui/input.go`\n- Implement `Prepare()` using existing `agui.ToGainsMessages()` and `agui.ParseTools()`\n- Update `cmd/aguiserver/handler.go` to use the library type\n- Add tests for validation edge cases (empty messages, malformed tools)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T21:20:47.016824368-08:00","updated_at":"2025-12-17T21:32:35.917276123-08:00","closed_at":"2025-12-17T21:32:35.917276123-08:00","close_reason":"Closed"}
{"id":"gains-3kh","title":"Add ChatTyped helper for auto-unmarshal structured output","description":"## Problem\nUsers currently do manual json.Unmarshal after WithResponseSchema:\n```go\nresp, err := c.Chat(ctx, msgs, ai.WithResponseSchema(ai.ResponseSchema{\n    Name: \"book\", Schema: ai.MustSchemaFor[BookInfo](),\n}))\nvar book BookInfo\njson.Unmarshal([]byte(resp.Content), \u0026book)\n```\n\n## Proposed Solution\n```go\nbook, err := client.ChatTyped[BookInfo](ctx, c, msgs)\n// With options\nbook, err := client.ChatTyped[BookInfo](ctx, c, msgs, ai.WithTemperature(0.5))\n```\n\n## Design Decisions\n- Package-level function (Go generics don't allow type params on methods)\n- Signature: `func ChatTyped[T any](ctx context.Context, c *Client, msgs []Message, opts ...Option) (T, error)`\n- Schema name derived from type name via reflection\n- Passes through all options to underlying Chat call\n- Related: workflow.TypedPromptStep does similar for workflows; this is standalone version","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:26:31.1855741-08:00","updated_at":"2025-12-17T18:02:41.2093773-08:00","closed_at":"2025-12-17T18:02:41.2093773-08:00","close_reason":"Closed"}
{"id":"gains-4hd","title":"Add type-safe Set for workflow state","description":"## Problem\nThe workflow state allows bypassing the typed Key[T] system:\n```go\nvar KeyCount = workflow.NewKey[int](\"count\")\nstate.Set(\"count\", \"not an int\")  // No compile error!\ncount := workflow.Get(state, KeyCount)  // Runtime panic or zero value\n```\n\n## Proposed Solution\nAdd typed Set function that mirrors Get:\n```go\n// Type-safe set (new)\nworkflow.Set(state, KeyCount, 42)\n// workflow.Set(state, KeyCount, \"not an int\")  // Compile error!\n\n// Signature\nfunc Set[T any](state State, key Key[T], value T)\n```\n\n## Implementation\n- Add `func Set[T any](s State, key Key[T], value T)` to workflow package\n- Deprecate raw `state.Set(string, any)` or make it internal\n- Update existing code to use typed Set","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-17T17:49:38.8508839-08:00","updated_at":"2025-12-17T18:33:59.7873733-08:00","closed_at":"2025-12-17T18:33:59.7873733-08:00","close_reason":"Set[T] already exists in typed.go. Updated state.go docs to recommend the typed Key[T] API for compile-time type safety."}
{"id":"gains-4zt","title":"Add fluent builder API for tool Registry","description":"## Problem\nCurrent registration is repetitive for many tools:\n```go\nregistry := tool.NewRegistry()\ntool.MustRegisterFunc(registry, \"weather\", \"...\", weatherFn)\ntool.MustRegisterFunc(registry, \"search\", \"...\", searchFn)\ntool.MustRegisterFunc(registry, \"calc\", \"...\", calcFn)\n```\n\n## Proposed Solution\nFluent builder pattern:\n```go\nregistry := tool.NewRegistry().\n    Func(\"weather\", \"Get weather\", weatherFn).\n    Func(\"search\", \"Search web\", searchFn).\n    Func(\"calc\", \"Calculate\", calcFn)\n```\n\n## Design Decisions\n- Panic immediately on each .Func() call (consistent with Must* pattern)\n- No .Build() needed - chain methods return *Registry, ready to use\n- Consider additional methods: .Handler() for interface types, .Tool() for pre-built pairs","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:30:37.8407097-08:00","updated_at":"2025-12-17T18:09:18.6902788-08:00","closed_at":"2025-12-17T18:09:18.6902788-08:00","close_reason":"Closed"}
{"id":"gains-d62","title":"Add unified error handling with categories","description":"## Problem\nErrors are inconsistent across packages. No standard way to know if an error is retryable or what action to take.\n\n## Proposed Solution\n```go\n// In gains/errors.go\ntype ErrorCategory string\nconst (\n    ErrorTransient  ErrorCategory = \"transient\"  // retry-able\n    ErrorPermanent  ErrorCategory = \"permanent\"  // don't retry\n    ErrorUserInput  ErrorCategory = \"user_input\" // user must fix\n)\n\ntype CategorizedError interface {\n    error\n    Category() ErrorCategory\n    Retryable() bool           // convenience (Category == Transient)\n    StatusCode() int           // HTTP status if applicable (0 if not)\n    RetryAfter() time.Duration // from header if available (0 if not)\n}\n\n// Helper functions\nfunc IsTransient(err error) bool\nfunc IsPermanent(err error) bool\nfunc IsUserInput(err error) bool\n```\n\n## Design Decisions\n- Interface-based for flexibility (any error can implement it)\n- Include metadata: StatusCode, RetryAfter for richer error handling\n- Helper functions to check category without type assertion\n- Integrate with internal/retry package - only retry transient errors\n- Wrap provider SDK errors with appropriate categories:\n  - 429 Rate Limit → transient\n  - 401 Unauthorized → permanent  \n  - 400 Bad Request → user_input","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:35:17.5175731-08:00","updated_at":"2025-12-17T18:28:45.9383285-08:00","closed_at":"2025-12-17T18:28:45.9383285-08:00","close_reason":"Closed"}
{"id":"gains-es9","title":"Rethink agent as native workflow pattern","description":"## Problem\nCurrent architecture has agent as a separate package that workflow wraps via AgentStep. This creates:\n- Adapter complexity (ChatClient interfaces, event mapping)\n- Two mental models (agent vs workflow)\n- AgentStep feels bolted-on rather than native\n\n## Key Insight\nAn autonomous agent IS a workflow pattern. Like Chain, Parallel, Router, Loop - agent is fundamentally:\n```\nLoop(\n  PromptStep -\u003e ToolExecutionStep,\n  until: no tool calls or max steps\n)\n```\n\nA \"standard autonomous agent\" is just a workflow with one agent step.\n\n## Questions to Explore\n1. Can agent become a native workflow primitive (like Loop)?\n2. Should workflow subsume agent entirely?\n3. What's the minimal interface for tool-calling within workflow?\n4. How do approval workflows fit in?\n\n## Blocked\nIntentionally blocked for design rethinking. Previous implementation attempts added unwanted adapter complexity.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:32:21.7698258-08:00","updated_at":"2025-12-17T18:50:54.3804986-08:00","closed_at":"2025-12-17T18:50:54.3804986-08:00","close_reason":"## Analysis Complete\n\n**Decision: Keep current architecture. AgentStep adapter is the right level of abstraction.**\n\n### Key Findings\n\n1. **Agent should NOT become a native workflow primitive**\n   - Agent has unique semantics: internal tool-loop, approval mid-execution, termination logic\n   - Making it native would conflate \"autonomous tool-calling\" with \"step orchestration\"\n\n2. **Workflow should NOT subsume agent**\n   - Different purposes: Agent = autonomous, Workflow = composable patterns\n   - Agent is correctly a \"black box\" step\n   - Backward compatibility matters\n\n3. **Minimal tool-calling interface already exists**\n   - ToolStep for deterministic single-tool execution\n   - AgentStep for LLM-orchestrated tool use\n   - Compose with Chain/Parallel/Router for complex flows\n\n4. **Approval belongs in agent** (mid-loop, before tool execution)\n\n### On \"Adapter Complexity\"\n\nThe AgentStep.RunStream() mapping (120+ lines) is verbose but mechanical. The agent and workflow event systems are nearly identical - the adapter just adds StepName and reconstructs message history.\n\nThis is acceptable overhead for clean separation of concerns. The alternative (merging packages) would create more problems than it solves.\n\n### Recommendation\n\nNo changes needed. Document when to use:\n- `ToolStep`: Deterministic, programmatic tool execution\n- `AgentStep`: Autonomous, LLM-decides tool execution"}
{"id":"gains-idz","title":"Add ChatOnce helper for single-turn chat","description":"## Problem\nCurrently the simplest chat requires ~8 lines:\n```go\nc := client.New(client.Config{...})\nresp, err := c.Chat(ctx, []ai.Message{{Role: ai.RoleUser, Content: \"Hello\"}})\n```\n\n## Proposed Solution\nAdd a one-liner helper:\n```go\nresp, err := client.ChatOnce(ctx, \"Hello\", client.WithAPIKey(key), ai.WithModel(model.ClaudeSonnet45))\n```\n\n## Design Decision\n**Approach A**: Support tools via ai.WithTools() but don't execute them automatically. Returns response with ToolCalls if model requests them; caller handles execution. Keeps it simple and predictable.\n\n## Implementation Notes\n- Package-level function in client package\n- Creates ephemeral client internally\n- Supports all ai.Option types\n- Provider selected based on model option\n- No tool execution loop (use agent.Agent for that)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:18:54.7290718-08:00","updated_at":"2025-12-17T17:59:49.3141819-08:00","closed_at":"2025-12-17T17:59:49.3141819-08:00","close_reason":"wontfix"}
{"id":"gains-k3g","title":"Remove tools-in-basic-Chat demo and docs","description":"## Context\nAfter review, tools in basic Chat has no coherent use case that isn't better served by:\n- Agent (for tool execution, even single-step with WithMaxSteps(1))\n- ChatTyped (for structured output)\n\nThe current demo teaches a pattern nobody should use in production.\n\n## Changes\n1. Remove cmd/demo/tools.go (manual two-round tool loop example)\n2. Update README to not show tools with basic Chat\n3. Update any godoc that suggests using WithTools directly\n4. Keep WithTools public (Agent uses it internally) but don't document for direct use\n\n## Files to Review\n- cmd/demo/tools.go - DELETE\n- README.md - remove tool examples with basic Chat\n- doc.go - update if needed\n- options.go godoc - consider noting 'used internally by Agent'","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T17:45:57.657638-08:00","updated_at":"2025-12-17T18:32:07.0076683-08:00","closed_at":"2025-12-17T18:32:07.0076683-08:00","close_reason":"Closed"}
{"id":"gains-ppl","title":"Add Mapper.MapStream helper for filtered event streaming","description":"## Summary\nAdd a convenience method to `agui.Mapper` that wraps a gains event channel and yields only non-nil AG-UI events. This encapsulates the common streaming pattern used in every AG-UI server.\n\n## Current State\nEvery AG-UI server implementation must write this same loop:\n\n```go\nmapper := agui.NewMapper(threadID, runID)\nfor ev := range agent.RunStream(ctx, messages) {\n    aguiEvent := mapper.MapEvent(ev)\n    if aguiEvent == nil {\n        continue // Skip events with no AG-UI equivalent\n    }\n    writeEvent(aguiEvent)  // transport-specific\n}\n```\n\n## Proposed API\nAdd to `agui/mapper.go`:\n\n```go\n// MapStream wraps a gains event channel and yields AG-UI events.\n// Events that have no AG-UI equivalent (returning nil from MapEvent) are filtered out.\n// The returned channel closes when the input channel closes.\nfunc (m *Mapper) MapStream(events \u003c-chan event.Event) \u003c-chan events.Event\n```\n\n## Usage Example\n```go\nmapper := agui.NewMapper(threadID, runID)\n\n// User handles transport-specific writing\nfor aguiEvent := range mapper.MapStream(agent.RunStream(ctx, messages)) {\n    writeSSE(w, aguiEvent)  // or websocket, or whatever transport\n}\n```\n\n## Benefits\n1. Reduces boilerplate in every server implementation\n2. Encapsulates the nil-filtering logic\n3. Cleaner separation: library handles event mapping, user handles transport\n4. Less room for errors (forgetting the nil check)\n\n## Implementation Notes\n- Spawn a goroutine that reads from input, maps, filters nils, writes to output\n- Close output channel when input closes\n- Consider if context cancellation should be supported (probably via input channel closing)\n- Add tests verifying nil events are filtered\n- Update `cmd/aguiserver/handler.go` to use the new helper","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-17T21:26:51.990154624-08:00","updated_at":"2025-12-17T21:26:51.990154624-08:00"}
