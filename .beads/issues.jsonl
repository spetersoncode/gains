{"id":"gains-25z","title":"Document state snapshot/checkpoint pattern","description":"## Background\nState snapshots/checkpoints were requested but declined as a new feature because the pattern already exists via `State.Sync()`. However, this isn't documented.\n\n## What to Document\nShow users how to implement checkpointing with existing APIs:\n\n```go\n// Create state with a file adapter for persistence\nadapter := store.NewFileAdapter(\"workflow-state.json\")\nstate := workflow.NewState(adapter)\n\n// Checkpoint after expensive steps\nchain := workflow.NewChain(\"pipeline\",\n    expensiveStep1,\n    workflow.NewFuncStep(\"checkpoint-1\", func(ctx context.Context, s *workflow.State) error {\n        return s.Sync(ctx)  // Persist to file\n    }),\n    expensiveStep2,\n    workflow.NewFuncStep(\"checkpoint-2\", func(ctx context.Context, s *workflow.State) error {\n        return s.Sync(ctx)\n    }),\n)\n\n// Resume from checkpoint on restart\nstate.Reload(ctx)  // Load previous state\n```\n\n## Deliverables\n1. Add \"Checkpointing\" section to `workflow/doc.go`\n2. Create example in `cmd/demo/` showing checkpoint/resume pattern\n3. Document `StateAdapter` interface for custom persistence backends","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-18T19:25:38.318562524-08:00","updated_at":"2025-12-18T19:25:38.318562524-08:00"}
{"id":"gains-2of","title":"Consolidate Handler types into Handler[T]","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-18T20:40:31.347143627-08:00","updated_at":"2025-12-18T20:40:31.347143627-08:00"}
{"id":"gains-2pb","title":"Add RunAgentInput type and Prepare helper to agui package","description":"## Summary\nMove the `RunAgentInput` struct from `cmd/aguiserver/handler.go` to the `agui` package. This type represents the AG-UI protocol's request schema and is transport-agnostic - every AG-UI server implementation needs this regardless of HTTP framework.\n\n## Current State\nThe type is defined in `cmd/aguiserver/handler.go:18-28`:\n```go\ntype RunAgentInput struct {\n    ThreadID       string                `json:\"thread_id\"`\n    RunID          string                `json:\"run_id\"`\n    Messages       []aguievents.Message  `json:\"messages\"`\n    Tools          []any                 `json:\"tools,omitempty\"`\n    Context        []any                 `json:\"context,omitempty\"`\n    State          any                   `json:\"state,omitempty\"`\n    ForwardedProps any                   `json:\"forwarded_props,omitempty\"`\n}\n```\n\nThe handler then has scattered logic to validate and convert this input (lines 67-100).\n\n## Proposed API\nAdd to `agui/input.go`:\n\n```go\n// RunAgentInput represents the AG-UI protocol request for running an agent.\n// This mirrors the AG-UI protocol specification.\ntype RunAgentInput struct {\n    ThreadID       string           `json:\"thread_id\"`\n    RunID          string           `json:\"run_id\"`\n    Messages       []events.Message `json:\"messages\"`\n    Tools          []any            `json:\"tools,omitempty\"`\n    Context        []any            `json:\"context,omitempty\"`\n    State          any              `json:\"state,omitempty\"`\n    ForwardedProps any              `json:\"forwarded_props,omitempty\"`\n}\n\n// PreparedInput contains validated and converted input ready for agent execution.\ntype PreparedInput struct {\n    ThreadID  string\n    RunID     string\n    Messages  []gains.Message\n    Tools     []Tool           // Parsed frontend tools\n    ToolNames []string         // Tool names for cleanup tracking\n}\n\n// Prepare validates the input and converts it to gains types.\n// Returns an error if Messages is empty or tool parsing fails.\nfunc (r *RunAgentInput) Prepare() (*PreparedInput, error)\n```\n\n## Benefits\n1. Documents the protocol schema in the library where it belongs\n2. Consolidates validation and conversion logic in one place\n3. Makes server implementations cleaner - they focus on HTTP concerns only\n4. Enables consistent behavior across different server implementations\n5. Users don't need to re-implement the same parsing/validation\n\n## Implementation Notes\n- Move type definition to `agui/input.go`\n- Implement `Prepare()` using existing `agui.ToGainsMessages()` and `agui.ParseTools()`\n- Update `cmd/aguiserver/handler.go` to use the library type\n- Add tests for validation edge cases (empty messages, malformed tools)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T21:20:47.016824368-08:00","updated_at":"2025-12-17T21:32:35.917276123-08:00","closed_at":"2025-12-17T21:32:35.917276123-08:00","close_reason":"Closed"}
{"id":"gains-2wq","title":"Add workflow.Describe() for Mermaid visualization","description":"## Problem\nComplex workflows are hard to visualize and document. Users want to see the structure of their workflows without running them.\n\n## Solution\nAdd a `Describe()` method that outputs Mermaid diagram syntax:\n\n```go\nwf := workflow.New(\"analysis-pipeline\", \n    workflow.NewChain(\"main\",\n        setupStep,\n        workflow.NewParallel(\"research\", researchSteps, nil),\n        workflow.NewRouter(\"route\", routes, defaultRoute),\n        summarizeStep,\n    ),\n)\n\nfmt.Println(wf.Describe())\n```\n\nOutput:\n```mermaid\nflowchart TD\n    subgraph analysis-pipeline\n        setup[setup]\n        subgraph research[research - parallel]\n            research-1[scientific]\n            research-2[historical]\n            research-3[cultural]\n        end\n        route{route}\n        route --\u003e|billing| billing[billing-handler]\n        route --\u003e|technical| technical[tech-handler]\n        route --\u003e|default| general[general-handler]\n        summarize[summarize]\n        \n        setup --\u003e research\n        research --\u003e route\n        route --\u003e summarize\n    end\n```\n\n## Implementation\n1. Add `Describe() string` method to `Step` interface\n2. Implement for each step type:\n   - FuncStep: simple box\n   - PromptStep: box with LLM indicator\n   - Chain: sequential arrows\n   - Parallel: subgraph with parallel boxes\n   - Router: decision diamond with labeled arrows\n   - Loop: subgraph with back-arrow\n3. Add `Workflow.Describe()` that wraps root step\n4. Handle nested compositions recursively\n5. Add option for different output formats (Mermaid, ASCII, DOT)","status":"open","priority":4,"issue_type":"feature","created_at":"2025-12-18T19:20:37.326945556-08:00","updated_at":"2025-12-18T19:20:37.326945556-08:00"}
{"id":"gains-3db","title":"Plan comprehensive retry system revamp","description":"## Background\nThe current retry implementation lives in `internal/retry/` and is only used at the client level. Feedback suggests retry needs to work at multiple levels. Before implementing, we need a comprehensive plan.\n\n## Current State\n- `internal/retry/config.go`: Retry configuration (attempts, backoff, jitter)\n- `internal/retry/retry.go`: Core retry logic with exponential backoff\n- `client/retry.go`: Client-level retry integration\n\n## Questions to Answer\n1. **Where should retry happen?**\n   - Provider level (inside anthropic/openai/google clients)?\n   - Client level (current - wraps all provider calls)?\n   - Step level (workflow steps can retry)?\n   - All of the above?\n\n2. **What should be retryable?**\n   - HTTP 429 rate limits\n   - HTTP 5xx server errors\n   - Network timeouts\n   - Context deadline exceeded\n   - Provider-specific retryable errors\n   - Tool execution failures?\n\n3. **Configuration scope**\n   - Global defaults\n   - Per-provider overrides\n   - Per-step overrides\n   - Per-call overrides\n   - How do these compose/override?\n\n4. **Observability**\n   - Events for retry attempts?\n   - Logging hooks?\n   - Metrics integration?\n\n## Deliverable\nCreate beads epic with implementation tasks covering:\n- Retry architecture across client/agent/workflow\n- Configuration hierarchy\n- Error classification (what's retryable)\n- Event/observability integration\n- API surface changes\n- Dependency graph for implementation order\n\n## Out of Scope\n- Circuit breaker pattern (future)\n- Rate limit pre-flight checks (future)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T19:21:29.973585913-08:00","updated_at":"2025-12-18T19:21:29.973585913-08:00"}
{"id":"gains-3kh","title":"Add ChatTyped helper for auto-unmarshal structured output","description":"## Problem\nUsers currently do manual json.Unmarshal after WithResponseSchema:\n```go\nresp, err := c.Chat(ctx, msgs, ai.WithResponseSchema(ai.ResponseSchema{\n    Name: \"book\", Schema: ai.MustSchemaFor[BookInfo](),\n}))\nvar book BookInfo\njson.Unmarshal([]byte(resp.Content), \u0026book)\n```\n\n## Proposed Solution\n```go\nbook, err := client.ChatTyped[BookInfo](ctx, c, msgs)\n// With options\nbook, err := client.ChatTyped[BookInfo](ctx, c, msgs, ai.WithTemperature(0.5))\n```\n\n## Design Decisions\n- Package-level function (Go generics don't allow type params on methods)\n- Signature: `func ChatTyped[T any](ctx context.Context, c *Client, msgs []Message, opts ...Option) (T, error)`\n- Schema name derived from type name via reflection\n- Passes through all options to underlying Chat call\n- Related: workflow.TypedPromptStep does similar for workflows; this is standalone version","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:26:31.1855741-08:00","updated_at":"2025-12-17T18:02:41.2093773-08:00","closed_at":"2025-12-17T18:02:41.2093773-08:00","close_reason":"Closed"}
{"id":"gains-3pt","title":"Review and improve godoc documentation","description":"## Background\nComprehensive godoc review to ensure all public APIs are well-documented.\n\n## Scope\nReview all public packages:\n- `gains` (root) - Core types\n- `client` - Unified client\n- `agent` - Agent orchestration\n- `workflow` - Workflow patterns\n- `tool` - Tool infrastructure\n- `event` - Event types\n- `agui` - AG-UI protocol\n- `model` - Model constants\n\n## Checklist per Package\n- [ ] Package doc.go has comprehensive overview\n- [ ] All exported types have doc comments\n- [ ] All exported functions have doc comments with examples\n- [ ] Complex functions have usage examples\n- [ ] Cross-references to related types/functions\n- [ ] No broken links or outdated references\n\n## Specific Areas to Review\n1. `workflow` package - ensure all step types documented with examples\n2. `tool` package - ensure binding patterns documented\n3. `client` package - ensure option patterns documented\n4. `agent` package - ensure approval workflow documented\n\n## Deliverable\nFix all documentation gaps found during review","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-18T19:25:40.459246665-08:00","updated_at":"2025-12-18T19:25:40.459246665-08:00"}
{"id":"gains-3vo","title":"Remove Key helper functions","description":"","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-18T20:40:31.484615854-08:00","updated_at":"2025-12-18T20:40:31.484615854-08:00"}
{"id":"gains-3yr","title":"Consolidate Parallel types into Parallel[T]","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-18T20:40:31.21405889-08:00","updated_at":"2025-12-18T20:40:31.21405889-08:00"}
{"id":"gains-4hd","title":"Add type-safe Set for workflow state","description":"## Problem\nThe workflow state allows bypassing the typed Key[T] system:\n```go\nvar KeyCount = workflow.NewKey[int](\"count\")\nstate.Set(\"count\", \"not an int\")  // No compile error!\ncount := workflow.Get(state, KeyCount)  // Runtime panic or zero value\n```\n\n## Proposed Solution\nAdd typed Set function that mirrors Get:\n```go\n// Type-safe set (new)\nworkflow.Set(state, KeyCount, 42)\n// workflow.Set(state, KeyCount, \"not an int\")  // Compile error!\n\n// Signature\nfunc Set[T any](state State, key Key[T], value T)\n```\n\n## Implementation\n- Add `func Set[T any](s State, key Key[T], value T)` to workflow package\n- Deprecate raw `state.Set(string, any)` or make it internal\n- Update existing code to use typed Set","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-17T17:49:38.8508839-08:00","updated_at":"2025-12-17T18:33:59.7873733-08:00","closed_at":"2025-12-17T18:33:59.7873733-08:00","close_reason":"Set[T] already exists in typed.go. Updated state.go docs to recommend the typed Key[T] API for compile-time type safety."}
{"id":"gains-4zt","title":"Add fluent builder API for tool Registry","description":"## Problem\nCurrent registration is repetitive for many tools:\n```go\nregistry := tool.NewRegistry()\ntool.MustRegisterFunc(registry, \"weather\", \"...\", weatherFn)\ntool.MustRegisterFunc(registry, \"search\", \"...\", searchFn)\ntool.MustRegisterFunc(registry, \"calc\", \"...\", calcFn)\n```\n\n## Proposed Solution\nFluent builder pattern:\n```go\nregistry := tool.NewRegistry().\n    Func(\"weather\", \"Get weather\", weatherFn).\n    Func(\"search\", \"Search web\", searchFn).\n    Func(\"calc\", \"Calculate\", calcFn)\n```\n\n## Design Decisions\n- Panic immediately on each .Func() call (consistent with Must* pattern)\n- No .Build() needed - chain methods return *Registry, ready to use\n- Consider additional methods: .Handler() for interface types, .Tool() for pre-built pairs","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:30:37.8407097-08:00","updated_at":"2025-12-17T18:09:18.6902788-08:00","closed_at":"2025-12-17T18:09:18.6902788-08:00","close_reason":"Closed"}
{"id":"gains-56m","title":"Add merge strategy options for Parallel","description":"## Problem\nCommon parallel state merge patterns require writing a full custom aggregator, which is boilerplate-heavy. Current code:\n\n```go\nparallel := workflow.NewParallel(\"steps\", steps, func(state *State, results map[string]*StepResult, errors map[string]error) error {\n    // Just want to merge specific keys\n    for _, result := range results {\n        branchState := workflow.GetBranchState(result)\n        if val, ok := workflow.Get(branchState, KeyOutput); ok {\n            // manual merge logic\n        }\n    }\n    return nil\n})\n```\n\n## Solution\nAdd merge strategy options that handle common patterns:\n\n```go\n// Merge all keys from all branches (current default)\nworkflow.NewParallel(\"steps\", steps, nil) // or explicit:\nworkflow.NewParallel(\"steps\", steps, workflow.MergeAll())\n\n// Merge only specific keys\nworkflow.NewParallel(\"steps\", steps, workflow.MergeKeys(\"output\", \"metadata\"))\n\n// Type-safe key merge\nworkflow.NewParallel(\"steps\", steps, workflow.MergeTypedKeys(KeyOutput, KeyMetadata))\n\n// Collect values from all branches into a slice under a single key\nworkflow.NewParallel(\"steps\", steps, workflow.CollectInto[string](KeyResults))\n```\n\n## Implementation\n1. Add `MergeStrategy` interface or function type\n2. Implement `MergeAll()` - current default behavior\n3. Implement `MergeKeys(keys ...string)` - merge only named keys\n4. Implement `MergeTypedKeys[T](keys ...Key[T])` - type-safe variant\n5. Implement `CollectInto[T](key Key[[]T])` - collect branch values into slice\n6. Update Parallel to accept either Aggregator or MergeStrategy\n7. Add tests and documentation","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-18T19:17:54.767987783-08:00","updated_at":"2025-12-18T20:01:20.476760008-08:00","closed_at":"2025-12-18T20:01:20.476760008-08:00","close_reason":"Closed"}
{"id":"gains-5o9","title":"Add GetFromBranch helper for parallel state access","description":"## Problem\nWhen using Parallel with a custom aggregator, branch states are buried in `result.Metadata[\"branch_state\"]`. Users must manually fish out typed values:\n\n```go\naggregator := func(state *State, results map[string]*StepResult) error {\n    for name, result := range results {\n        if branchState, ok := result.Metadata[\"branch_state\"].(*State); ok {\n            // Manually extract what we need\n            riff := workflow.MustGet(branchState, KeyRiff)\n        }\n    }\n}\n```\n\n## Solution\nAdd typed helper functions:\n\n```go\n// GetFromBranch extracts a typed value from a branch's state within StepResult\nfunc GetFromBranch[T any](result *StepResult, key Key[T]) (T, bool)\n\n// MustGetFromBranch panics if key not found or type mismatch\nfunc MustGetFromBranch[T any](result *StepResult, key Key[T]) T\n\n// GetBranchState extracts the full branch state from a result\nfunc GetBranchState(result *StepResult) (*State, bool)\n```\n\nUsage becomes:\n```go\naggregator := func(state *State, results map[string]*StepResult) error {\n    for name, result := range results {\n        riff := workflow.MustGetFromBranch(result, KeyRiff)\n    }\n}\n```\n\n## Implementation\n1. Add helpers to `workflow/typed.go`\n2. Add tests\n3. Document in `workflow/doc.go` Parallel section","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-18T19:16:37.992360052-08:00","updated_at":"2025-12-18T19:42:57.961042304-08:00","closed_at":"2025-12-18T19:42:57.961042304-08:00","close_reason":"Closed"}
{"id":"gains-64z","title":"Update docs/workflow.md after workflow improvements","description":"## Background\nAfter completing the workflow improvement tasks, the documentation in `docs/` needs to be updated to reflect new features.\n\n## Prerequisites\nThis task should be done AFTER:\n- gains-5o9: GetFromBranch helper\n- gains-9as: Parallel error visibility\n- gains-56m: Merge strategy options\n- gains-8b7: TypedParallel (if completed)\n\n## Updates Needed\n1. **Parallel section**: Document new features\n   - GetFromBranch helper usage\n   - New Aggregator signature with errors parameter\n   - MergeStrategy options (MergeAll, MergeKeys, CollectInto)\n   - TypedParallel usage (if implemented)\n\n2. **Error handling section**: Document parallel error visibility\n   - How errors are passed to aggregator\n   - StepSkipped events in ContinueOnError mode\n\n3. **Examples**: Update or add examples showing new patterns\n\n## Deliverable\nUpdated `docs/workflow.md` with comprehensive documentation of new workflow features","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-18T19:25:42.429062136-08:00","updated_at":"2025-12-18T20:11:53.281445582-08:00","closed_at":"2025-12-18T20:11:53.281445582-08:00","close_reason":"Closed","dependencies":[{"issue_id":"gains-64z","depends_on_id":"gains-5o9","type":"blocks","created_at":"2025-12-18T19:25:51.732005545-08:00","created_by":"daemon"},{"issue_id":"gains-64z","depends_on_id":"gains-9as","type":"blocks","created_at":"2025-12-18T19:25:51.830561758-08:00","created_by":"daemon"},{"issue_id":"gains-64z","depends_on_id":"gains-56m","type":"blocks","created_at":"2025-12-18T19:25:51.92675764-08:00","created_by":"daemon"}]}
{"id":"gains-8b7","title":"Add TypedParallel for homogeneous branches","description":"## Problem\nWhen running parallel branches that all produce the same type (e.g., analyzing chunks), the current pattern requires a custom aggregator with type assertions:\n\n```go\nparallel := workflow.NewParallel(\"riffs\", steps, func(state *State, results map[string]*StepResult, errors map[string]error) error {\n    var riffs []Riff\n    for _, result := range results {\n        if riff, ok := workflow.GetFromBranch(result, KeyRiff); ok {\n            riffs = append(riffs, riff)\n        }\n    }\n    workflow.Set(state, KeyAllRiffs, riffs)\n    return nil\n})\n```\n\n## Solution\nAdd `TypedParallel[T]` for homogeneous branches:\n\n```go\n// All branches produce type T, collected into []T\ntype TypedParallel[T any] struct {\n    name      string\n    steps     []Step\n    outputKey Key[[]T]\n    inputKey  Key[T]  // Key each branch writes to\n}\n\n// Usage\nparallel := workflow.NewTypedParallel[Riff](\n    \"riffs\",\n    steps,\n    KeyRiff,        // Each branch writes here\n    KeyAllRiffs,    // Collected results go here\n)\n\n// After execution: state has KeyAllRiffs = []Riff{...}\n```\n\nCan also support a typed aggregator for custom combination logic:\n\n```go\nworkflow.NewTypedParallelWithAggregator[Riff, Summary](\n    \"riffs\",\n    steps,\n    KeyRiff,\n    func(results []Riff) Summary { return combineRiffs(results) },\n    KeySummary,\n)\n```\n\n## Implementation\n1. Add `TypedParallel[T]` struct to `workflow/typed.go`\n2. Implement `NewTypedParallel[T]` constructor\n3. Implement `NewTypedParallelWithAggregator[T, U]` variant\n4. Run/RunStream automatically collect typed results\n5. Handle errors consistently with regular Parallel\n6. Add tests and examples","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-18T19:19:50.217986444-08:00","updated_at":"2025-12-18T20:04:09.827841759-08:00","closed_at":"2025-12-18T20:04:09.827841759-08:00","close_reason":"Closed"}
{"id":"gains-9as","title":"Improve parallel step error visibility","description":"## Problem\nWhen `ContinueOnError=true`, parallel step errors go into a map but the aggregator only receives successful results. Users have no visibility into which steps failed or why.\n\n## Current Behavior\n```go\n// In parallel.go:96-104\nif len(errors) \u003e 0 \u0026\u0026 !options.ContinueOnError {\n    return nil, \u0026ParallelError{Errors: errors}\n}\n// Aggregator only gets successful results\nif p.aggregator != nil {\n    p.aggregator(state, results)  // No error info passed!\n}\n```\n\n## Solution\nChange the Aggregator type signature to include errors:\n\n```go\n// Old:\ntype Aggregator func(state *State, results map[string]*StepResult) error\n\n// New:\ntype Aggregator func(state *State, results map[string]*StepResult, errors map[string]error) error\n```\n\nThis gives aggregators full visibility into what succeeded and what failed.\n\nAdditionally, emit warning events when steps fail in ContinueOnError mode so streaming consumers have visibility:\n```go\nevent.Emit(ch, Event{Type: event.StepSkipped, StepName: s.Name(), Error: err, Message: \"step failed, continuing\"})\n```\n\n## Implementation\n1. Update Aggregator type signature\n2. Update all call sites to pass errors map\n3. Emit StepSkipped events on failures when ContinueOnError=true  \n4. Update demo and docs","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-18T19:17:18.208541399-08:00","updated_at":"2025-12-18T19:53:10.137498898-08:00","closed_at":"2025-12-18T19:53:10.137498898-08:00","close_reason":"Closed"}
{"id":"gains-bg5","title":"Remove unused TypedStore[T]","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-18T20:40:30.332095948-08:00","updated_at":"2025-12-18T20:40:30.332095948-08:00"}
{"id":"gains-d62","title":"Add unified error handling with categories","description":"## Problem\nErrors are inconsistent across packages. No standard way to know if an error is retryable or what action to take.\n\n## Proposed Solution\n```go\n// In gains/errors.go\ntype ErrorCategory string\nconst (\n    ErrorTransient  ErrorCategory = \"transient\"  // retry-able\n    ErrorPermanent  ErrorCategory = \"permanent\"  // don't retry\n    ErrorUserInput  ErrorCategory = \"user_input\" // user must fix\n)\n\ntype CategorizedError interface {\n    error\n    Category() ErrorCategory\n    Retryable() bool           // convenience (Category == Transient)\n    StatusCode() int           // HTTP status if applicable (0 if not)\n    RetryAfter() time.Duration // from header if available (0 if not)\n}\n\n// Helper functions\nfunc IsTransient(err error) bool\nfunc IsPermanent(err error) bool\nfunc IsUserInput(err error) bool\n```\n\n## Design Decisions\n- Interface-based for flexibility (any error can implement it)\n- Include metadata: StatusCode, RetryAfter for richer error handling\n- Helper functions to check category without type assertion\n- Integrate with internal/retry package - only retry transient errors\n- Wrap provider SDK errors with appropriate categories:\n  - 429 Rate Limit → transient\n  - 401 Unauthorized → permanent  \n  - 400 Bad Request → user_input","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:35:17.5175731-08:00","updated_at":"2025-12-17T18:28:45.9383285-08:00","closed_at":"2025-12-17T18:28:45.9383285-08:00","close_reason":"Closed"}
{"id":"gains-e5o","title":"Remove WithKey constructor variants","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T20:40:30.913450567-08:00","updated_at":"2025-12-18T20:40:30.913450567-08:00","dependencies":[{"issue_id":"gains-e5o","depends_on_id":"gains-xyy","type":"blocks","created_at":"2025-12-18T20:40:44.529128279-08:00","created_by":"daemon"},{"issue_id":"gains-e5o","depends_on_id":"gains-g2i","type":"blocks","created_at":"2025-12-18T20:40:44.619359595-08:00","created_by":"daemon"}]}
{"id":"gains-es9","title":"Rethink agent as native workflow pattern","description":"## Problem\nCurrent architecture has agent as a separate package that workflow wraps via AgentStep. This creates:\n- Adapter complexity (ChatClient interfaces, event mapping)\n- Two mental models (agent vs workflow)\n- AgentStep feels bolted-on rather than native\n\n## Key Insight\nAn autonomous agent IS a workflow pattern. Like Chain, Parallel, Router, Loop - agent is fundamentally:\n```\nLoop(\n  PromptStep -\u003e ToolExecutionStep,\n  until: no tool calls or max steps\n)\n```\n\nA \"standard autonomous agent\" is just a workflow with one agent step.\n\n## Questions to Explore\n1. Can agent become a native workflow primitive (like Loop)?\n2. Should workflow subsume agent entirely?\n3. What's the minimal interface for tool-calling within workflow?\n4. How do approval workflows fit in?\n\n## Blocked\nIntentionally blocked for design rethinking. Previous implementation attempts added unwanted adapter complexity.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:32:21.7698258-08:00","updated_at":"2025-12-17T18:50:54.3804986-08:00","closed_at":"2025-12-17T18:50:54.3804986-08:00","close_reason":"## Analysis Complete\n\n**Decision: Keep current architecture. AgentStep adapter is the right level of abstraction.**\n\n### Key Findings\n\n1. **Agent should NOT become a native workflow primitive**\n   - Agent has unique semantics: internal tool-loop, approval mid-execution, termination logic\n   - Making it native would conflate \"autonomous tool-calling\" with \"step orchestration\"\n\n2. **Workflow should NOT subsume agent**\n   - Different purposes: Agent = autonomous, Workflow = composable patterns\n   - Agent is correctly a \"black box\" step\n   - Backward compatibility matters\n\n3. **Minimal tool-calling interface already exists**\n   - ToolStep for deterministic single-tool execution\n   - AgentStep for LLM-orchestrated tool use\n   - Compose with Chain/Parallel/Router for complex flows\n\n4. **Approval belongs in agent** (mid-loop, before tool execution)\n\n### On \"Adapter Complexity\"\n\nThe AgentStep.RunStream() mapping (120+ lines) is verbose but mechanical. The agent and workflow event systems are nearly identical - the adapter just adds StepName and reconstructs message history.\n\nThis is acceptable overhead for clean separation of concerns. The alternative (merging packages) would create more problems than it solves.\n\n### Recommendation\n\nNo changes needed. Document when to use:\n- `ToolStep`: Deterministic, programmatic tool execution\n- `AgentStep`: Autonomous, LLM-decides tool execution"}
{"id":"gains-g2i","title":"Consolidate PromptStep and TypedPromptStep into PromptStep[T]","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T20:40:30.622441012-08:00","updated_at":"2025-12-18T20:40:30.622441012-08:00"}
{"id":"gains-g3q","title":"Consolidate UnmarshalError types","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T20:40:31.05353409-08:00","updated_at":"2025-12-18T20:40:31.05353409-08:00"}
{"id":"gains-gre","title":"Unify ChatClient interface across packages","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-18T20:40:30.49824083-08:00","updated_at":"2025-12-18T20:40:30.49824083-08:00"}
{"id":"gains-hky","title":"Add cost calculation helpers","description":"## Problem\nThe library has `model.ChatPricing` with pricing data and tracks `Usage` on responses, but there's no easy way to calculate actual cost. Users can't answer \"how much did this workflow cost?\"\n\n## Current State\n```go\n// model/pricing.go has pricing\ntype ChatPricing struct {\n    InputPerMillion  float64\n    OutputPerMillion float64\n    // ...\n}\n\n// workflow/event.go tracks usage\ntype Result struct {\n    Usage ai.Usage  // Has InputTokens, OutputTokens\n}\n\n// But no way to calculate cost\n```\n\n## Solution\nAdd cost calculation helpers:\n\n```go\n// On ChatModel\nfunc (m ChatModel) Cost(usage ai.Usage) float64 {\n    pricing := m.Pricing()\n    return (float64(usage.InputTokens) * pricing.InputPerMillion / 1_000_000) +\n           (float64(usage.OutputTokens) * pricing.OutputPerMillion / 1_000_000)\n}\n\n// On workflow.Result\nfunc (r *Result) TotalCost(model ai.Model) float64 {\n    return model.Cost(r.Usage)\n}\n\n// Convenience for mixed-model workflows\nfunc CalculateCost(usage ai.Usage, pricing model.ChatPricing) float64\n```\n\n## Implementation\n1. Add `Cost(usage Usage) float64` method to `model.ChatModel`\n2. Add `TotalCost(model Model) float64` method to `workflow.Result`\n3. Add standalone `CalculateCost` for flexibility\n4. Handle edge cases (long context pricing for Google, cached tokens for OpenAI)\n5. Add tests with known pricing\n6. Document usage patterns","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-18T19:17:58.470876766-08:00","updated_at":"2025-12-18T19:57:59.673692292-08:00","closed_at":"2025-12-18T19:57:59.673692292-08:00","close_reason":"Closed"}
{"id":"gains-idz","title":"Add ChatOnce helper for single-turn chat","description":"## Problem\nCurrently the simplest chat requires ~8 lines:\n```go\nc := client.New(client.Config{...})\nresp, err := c.Chat(ctx, []ai.Message{{Role: ai.RoleUser, Content: \"Hello\"}})\n```\n\n## Proposed Solution\nAdd a one-liner helper:\n```go\nresp, err := client.ChatOnce(ctx, \"Hello\", client.WithAPIKey(key), ai.WithModel(model.ClaudeSonnet45))\n```\n\n## Design Decision\n**Approach A**: Support tools via ai.WithTools() but don't execute them automatically. Returns response with ToolCalls if model requests them; caller handles execution. Keeps it simple and predictable.\n\n## Implementation Notes\n- Package-level function in client package\n- Creates ephemeral client internally\n- Supports all ai.Option types\n- Provider selected based on model option\n- No tool execution loop (use agent.Agent for that)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:18:54.7290718-08:00","updated_at":"2025-12-17T17:59:49.3141819-08:00","closed_at":"2025-12-17T17:59:49.3141819-08:00","close_reason":"wontfix"}
{"id":"gains-k3g","title":"Remove tools-in-basic-Chat demo and docs","description":"## Context\nAfter review, tools in basic Chat has no coherent use case that isn't better served by:\n- Agent (for tool execution, even single-step with WithMaxSteps(1))\n- ChatTyped (for structured output)\n\nThe current demo teaches a pattern nobody should use in production.\n\n## Changes\n1. Remove cmd/demo/tools.go (manual two-round tool loop example)\n2. Update README to not show tools with basic Chat\n3. Update any godoc that suggests using WithTools directly\n4. Keep WithTools public (Agent uses it internally) but don't document for direct use\n\n## Files to Review\n- cmd/demo/tools.go - DELETE\n- README.md - remove tool examples with basic Chat\n- doc.go - update if needed\n- options.go godoc - consider noting 'used internally by Agent'","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-17T17:45:57.657638-08:00","updated_at":"2025-12-17T18:32:07.0076683-08:00","closed_at":"2025-12-17T18:32:07.0076683-08:00","close_reason":"Closed"}
{"id":"gains-l69","title":"Remove string-based Loop constructors, rename typed versions","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T20:40:30.777252071-08:00","updated_at":"2025-12-18T20:40:30.777252071-08:00"}
{"id":"gains-mog","title":"Change default step timeout from 30s to 2m","description":"The current default step timeout of 30 seconds is too short for many LLM operations. Increase to 2 minutes to provide more headroom for longer-running steps.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T19:00:29.241245054-08:00","updated_at":"2025-12-18T19:54:45.976780855-08:00","closed_at":"2025-12-18T19:54:45.976780855-08:00","close_reason":"Closed"}
{"id":"gains-ppl","title":"Add Mapper.MapStream helper for filtered event streaming","description":"## Summary\nAdd a convenience method to `agui.Mapper` that wraps a gains event channel and yields only non-nil AG-UI events. This encapsulates the common streaming pattern used in every AG-UI server.\n\n## Current State\nEvery AG-UI server implementation must write this same loop:\n\n```go\nmapper := agui.NewMapper(threadID, runID)\nfor ev := range agent.RunStream(ctx, messages) {\n    aguiEvent := mapper.MapEvent(ev)\n    if aguiEvent == nil {\n        continue // Skip events with no AG-UI equivalent\n    }\n    writeEvent(aguiEvent)  // transport-specific\n}\n```\n\n## Proposed API\nAdd to `agui/mapper.go`:\n\n```go\n// MapStream wraps a gains event channel and yields AG-UI events.\n// Events that have no AG-UI equivalent (returning nil from MapEvent) are filtered out.\n// The returned channel closes when the input channel closes.\nfunc (m *Mapper) MapStream(events \u003c-chan event.Event) \u003c-chan events.Event\n```\n\n## Usage Example\n```go\nmapper := agui.NewMapper(threadID, runID)\n\n// User handles transport-specific writing\nfor aguiEvent := range mapper.MapStream(agent.RunStream(ctx, messages)) {\n    writeSSE(w, aguiEvent)  // or websocket, or whatever transport\n}\n```\n\n## Benefits\n1. Reduces boilerplate in every server implementation\n2. Encapsulates the nil-filtering logic\n3. Cleaner separation: library handles event mapping, user handles transport\n4. Less room for errors (forgetting the nil check)\n\n## Implementation Notes\n- Spawn a goroutine that reads from input, maps, filters nils, writes to output\n- Close output channel when input closes\n- Consider if context cancellation should be supported (probably via input channel closing)\n- Add tests verifying nil events are filtered\n- Update `cmd/aguiserver/handler.go` to use the new helper","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T21:26:51.990154624-08:00","updated_at":"2025-12-17T21:36:35.010715026-08:00","closed_at":"2025-12-17T21:36:35.010715026-08:00","close_reason":"Implemented MapStream helper in agui/mapper.go with tests, updated aguiserver handler to use it"}
{"id":"gains-xyy","title":"Consolidate ToolStep and TypedToolStep into ToolStep[T]","description":"","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-18T20:40:25.573069112-08:00","updated_at":"2025-12-18T20:40:25.573069112-08:00"}
